---
interface Props {
  interval?: number;
}

const { interval = 8000 } = Astro.props as Props;
---

<div class="relative px-2 sm:px-5 lg:px-0 mx-auto max-w-[750px] max-h-[255px] w-auto" data-interval={interval}>
  <!-- Prev arrow -->
  <button
    class="hidden md:flex absolute top-1/2 left-0 -translate-y-1/2 -translate-x-[40%] lg:-translate-x-full z-10 w-10 h-10 items-center justify-center text-[40px] text-secondary cursor-pointer review-prev"
    id="carousel-prev"
    aria-label="Previous slide"
  >
    ‹
  </button>

  <!-- Viewport -->
  <div class="overflow-hidden w-auto h-full">
    <div class="flex transition-transform duration-800 ease-in-out review-track h-full" id="carousel-track">
      {Array.from({ length: 4 }, (_, i) => (
        <div class="flex-shrink-0 w-full md:w-1/2 h-full px-2 md:px-[10px]">
          <img
            src={`/main/item-0${i + 1}.png`}
            alt="Slide image"
            width="400"
            height="255"
            class="w-full h-full object-cover rounded-[15px]"
            loading="eager"
            decoding="async"
          />
        </div>
      ))}
    </div>
  </div>

  <!-- Next arrow -->
  <button
    class="hidden md:flex absolute top-1/2 right-0 -translate-y-1/2 translate-x-[40%] lg:translate-x-full z-10 w-10 h-10 items-center justify-center text-[40px] text-secondary cursor-pointer review-next"
    id="carousel-next"
    aria-label="Next slide"
  >
    ›
  </button>

  <!-- Mobile indicators -->
  <div class="flex md:hidden gap-4 justify-center mt-4 review-indicators" id="carousel-indicators">
    {Array.from({ length: 4 }, (_, i) => (
      <button
        class="w-2 h-2 rounded-full bg-[#D9D9D9]"
        data-index={i}
        id={`indicator-${i}`}
        aria-label={`Go to slide ${i + 1}`}
      />
    ))}
  </div>
</div>

<script is:inline>
  (function () {
    const carousels = Array.from(document.querySelectorAll('[data-interval]'));
    if (carousels.length === 0) return;

    carousels.forEach((carousel) => {
      function initCarousel() {
        if (carousel.dataset.inited) return;
        carousel.dataset.inited = '1';

        const track = carousel.querySelector('#carousel-track') || carousel.querySelector('.review-track');
        if (!track) return;
        const prevBtn = carousel.querySelector('#carousel-prev') || carousel.querySelector('.review-prev');
        const nextBtn = carousel.querySelector('#carousel-next') || carousel.querySelector('.review-next');
        const indicators = Array.from(carousel.querySelectorAll('.review-indicators button'));
        const intervalMs = parseInt(carousel.getAttribute('data-interval') || '8000', 10);

        let slides = Array.from(track.children);
        if (slides.length === 0) return;

        const firstClone = slides[0].cloneNode(true);
        const lastClone = slides[slides.length - 1].cloneNode(true);
        track.appendChild(firstClone);
        track.insertBefore(lastClone, track.firstChild);
        slides = Array.from(track.children);

        let currentIndex = 1;
        let isTransitioning = false;
        let autoSlide = null;

        function getSlideWidth() { return slides[0].getBoundingClientRect().width; }
        function goTo(index, smooth = true) { if (isTransitioning && smooth) return; track.style.transition = smooth ? 'transform 0.5s ease-in-out' : 'none'; track.style.transform = `translateX(-${getSlideWidth() * index}px)`; currentIndex = index; isTransitioning = smooth; }
        function updateIndicators() { let realIndex = currentIndex - 1; if (currentIndex === 0) realIndex = slides.length - 3; else if (currentIndex === slides.length - 1) realIndex = 0; indicators.forEach((btn, i) => btn.classList.toggle('bg-main', i === realIndex)); }

        track.addEventListener('transitionend', () => { if (slides[currentIndex] === firstClone) goTo(1, false); if (slides[currentIndex] === lastClone) goTo(slides.length - 2, false); isTransitioning = false; updateIndicators(); });

        prevBtn?.addEventListener('click', () => { goTo(currentIndex - 1); resetAuto(); });
        nextBtn?.addEventListener('click', () => { goTo(currentIndex + 1); resetAuto(); });
        indicators.forEach(btn => btn.addEventListener('click', () => { const idx = Number(btn.dataset.index) + 1; goTo(idx); resetAuto(); }));

        function startAuto() { if (autoSlide) clearInterval(autoSlide); autoSlide = setInterval(() => { goTo(currentIndex + 1); }, intervalMs); }
        function stopAuto() { if (autoSlide) { clearInterval(autoSlide); autoSlide = null; } }
        function resetAuto() { stopAuto(); startAuto(); }

        carousel.addEventListener('mouseenter', stopAuto);
        carousel.addEventListener('mouseleave', startAuto);

        // Swipe touch
        let startX = 0, deltaX = 0;
        track.addEventListener('touchstart', e => { startX = e.touches[0].clientX; stopAuto(); });
        track.addEventListener('touchend', e => { deltaX = e.changedTouches[0].clientX - startX; if (Math.abs(deltaX) > 50) { const dir = deltaX < 0 ? 1 : -1; goTo(currentIndex + dir); } resetAuto(); });

        function doInit() { slides = Array.from(track.children); goTo(1, false); updateIndicators(); startAuto(); }

        // Wait for images inside the track to load before calculating sizes
        const images = track.querySelectorAll('img');
        if (images.length === 0) doInit();
        else {
          let loaded = 0;
          images.forEach(img => {
            if (img.complete) loaded++;
            else { img.addEventListener('load', () => { loaded++; if (loaded === images.length) doInit(); }); img.addEventListener('error', () => { loaded++; if (loaded === images.length) doInit(); }); }
          });
          if (loaded === images.length) doInit();
        }

        // Debounce resize handling
        let resizeTimer;
        window.addEventListener('resize', () => { clearTimeout(resizeTimer); resizeTimer = setTimeout(() => { goTo(currentIndex, false); updateIndicators(); }, 120); });
      }

      // Observe each carousel and init when visible
      if ('IntersectionObserver' in window) {
        const io = new IntersectionObserver((entries, observer) => { entries.forEach(entry => { if (entry.isIntersecting) { if ('requestIdleCallback' in window) requestIdleCallback(() => initCarousel(), { timeout: 2000 }); else setTimeout(initCarousel, 300); observer.unobserve(entry.target); } }); }, { rootMargin: '300px' });
        io.observe(carousel);
      } else {
        if ('requestIdleCallback' in window) requestIdleCallback(() => initCarousel(), { timeout: 2000 }); else setTimeout(initCarousel, 300);
      }
    });
  })();
</script>