---
interface Props {
  images: string[];
  interval?: number;
}

const { images, interval = 8000 } = Astro.props as Props;
---

<div class="relative px-2 sm:px-5 lg:px-0 max-w-screen md:max-w-[600px] w-full mt-0 lg:mt-10" data-interval={interval}>
  <!-- Viewport -->
  <div class="overflow-hidden w-full h-auto ">
    <div class="flex transition-transform duration-800 ease-in-out slide-track h-full min-h-[387px] md:min-h-[400px]  select-none">
      {images.map((src) => (
        <div class="flex-shrink-0 w-full px-2 md:px-[10px] h-[387px] md:h-[400px] relative">
          {/* Slide content */}
          {/* Cada slide con <section> y fondo de imagen */}
          <section class="w-full h-full flex items-center justify-center relative">
            <img
              src={src}
              alt="Slide image"
              width="2048"
              height="1536"
              loading="lazy"
              decoding="async"
              class={`${src == '/main/firepits.webp'?"object-left md:object-center" :"object-center"} absolute inset-0 w-full h-full object-cover z-20 rounded-[15px] pointer-events-none`}
            />
          </section>
        </div>
      ))}
    </div>
  </div>
  <!-- Mobile indicators -->
  <div class="flex gap-4 justify-center mt-4 slide-indicators">
    {Array.from({ length: images.length }).map((_, i) => (
      <button
        class="w-2 h-2 rounded-full bg-[#D9D9D9] cursor-pointer"
        data-index={i}
        aria-label={`Go to slide ${i + 1}`}
      />
    ))}
  </div>
</div>

<script is:inline defer>
  window.addEventListener("load", () => {
    const carousel = document.querySelector("[data-interval]");
    if (!carousel) return;
    const track = carousel.querySelector(".slide-track");
    const indicators = [...carousel.querySelectorAll(".slide-indicators button")];
    const intervalMs = parseInt(carousel.dataset.interval || "8000", 10);

    let slides = [...track.children];
    const firstClone = slides[0].cloneNode(true);
    const lastClone = slides[slides.length - 1].cloneNode(true);
    track.append(firstClone);
    track.prepend(lastClone);
    slides = [...track.children];

    let currentIndex = 1, isTransitioning = false, autoSlide, isDragging = false, isInteracting = false;

    const getSlideWidth = () => slides[0].getBoundingClientRect().width;
    const goTo = (i, smooth = true) => {
      if (isTransitioning && smooth) return;
      track.style.transition = smooth ? "transform .5s ease-in-out" : "none";
      track.style.transform = `translateX(-${getSlideWidth() * i}px)`;
      currentIndex = i; isTransitioning = smooth;
    };
    const updateIndicators = () => {
      let realIndex = currentIndex - 1;
      if (currentIndex === 0) realIndex = slides.length - 3;
      else if (currentIndex === slides.length - 1) realIndex = 0;
      indicators.forEach((b,i) => b.classList.toggle("bg-main", i===realIndex));
    };

    track.addEventListener("transitionend", () => {
      if (slides[currentIndex] === firstClone) goTo(1, false);
      if (slides[currentIndex] === lastClone) goTo(slides.length - 2, false);
      isTransitioning = false; updateIndicators();
    });

    indicators.forEach(b => b.addEventListener("click", () => { goTo(+b.dataset.index+1); resetAuto(); }));

    let lastTime=0;
    const loopAuto = t => {
      if (!lastTime) lastTime = t;
      if (t-lastTime >= intervalMs && !isDragging && !isTransitioning) {
        goTo(currentIndex+1); lastTime = t;
      }
      autoSlide=requestAnimationFrame(loopAuto);
    };
    const startAuto = ()=>{stopAuto();autoSlide=requestAnimationFrame(loopAuto);}
    const stopAuto = ()=>{if(autoSlide)cancelAnimationFrame(autoSlide);}
    const resetAuto = ()=>{stopAuto();setTimeout(startAuto,100);};

    let startX=0, deltaX=0;
    track.addEventListener("touchstart", e => {startX=e.touches[0].clientX;isInteracting=true;stopAuto();},{passive:true});
    track.addEventListener("touchend", e => {deltaX=e.changedTouches[0].clientX-startX;isInteracting=false;
      if(Math.abs(deltaX)>50) goTo(currentIndex+(deltaX<0?1:-1)); resetAuto();},{passive:true});

    track.addEventListener("mousedown", e => {startX=e.clientX;isDragging=true;isInteracting=true;stopAuto();e.preventDefault();});
    document.addEventListener("mouseup", e => {
      if(!isDragging)return; deltaX=e.clientX-startX;isDragging=false;isInteracting=false;
      if(Math.abs(deltaX)>50) goTo(currentIndex+(deltaX<0?1:-1)); resetAuto();
    });

    const init=()=>{slides=[...track.children];goTo(1,false);updateIndicators();};
    window.addEventListener("resize", init);

    init(); startAuto();
  });
</script>

