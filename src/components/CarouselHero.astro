---
interface Props {
  images: string[];
  interval?: number;
}

const { images, interval = 8000 } = Astro.props as Props;
---

<div class="relative px-2 sm:px-5 lg:px-0 md:max-w-[90%] lg:max-w-[1138px] w-full hero-carousel" data-interval={interval}>
  <!-- Prev arrow -->
  <button
    class="hidden md:flex absolute top-1/2 left-0 -translate-y-1/2 -translate-x-full z-10 w-10 h-10 items-center justify-center text-[40px] text-secondary cursor-pointer hero-carousel-prev"
    aria-label="Previous slide"
  >
    ‹
  </button>

  <!-- Viewport -->
  <div class="overflow-hidden w-full h-full ">
    <div class="flex transition-transform duration-800 ease-in-out hero-carousel-track h-full min-h-[415px] ">
      {images.map((src) => (
        <div class="flex-shrink-0 w-full md:w-1/2 lg:w-1/3 px-2 md:px-[10px] h-[415px] relative">
          {/* Slide content */}
          {/* Cada slide con <section> y fondo de imagen */}
          <section class="w-full h-full flex items-center justify-center relative">
            <img
              src={src}
              alt="Slide image"
              width="2048"
              height="1536"
              loading="lazy"
              decoding="async"
              class="absolute inset-0 w-full h-full object-cover z-20 oobject-center rounded-[15px]"
            />
          </section>
        </div>
      ))}
    </div>
  </div>

  <!-- Next arrow -->
  <button
    class="hidden md:flex absolute top-1/2 right-0 -translate-y-1/2 translate-x-full z-10 w-10 h-10 items-center justify-center text-[40px] text-secondary cursor-pointer hero-carousel-next"
    aria-label="Next slide"
  >
    ›
  </button>

  <!-- Mobile indicators -->
  <div class="flex md:hidden gap-4 justify-center mt-4 hero-carousel-indicators">
    {Array.from({ length: images.length }).map((_, i) => (
      <button
        class="w-2 h-2 rounded-full bg-[#D9D9D9]"
        data-index={i}
        aria-label={`Go to slide ${i + 1}`}
      />
    ))}
  </div>
</div>

<script is:inline>
  (function () {
    if (typeof window === 'undefined') return;

    const debounce = (fn, ms = 100) => {
      let t;
      return (...a) => { clearTimeout(t); t = setTimeout(() => fn.apply(this, a), ms); };
    };

    function initCarousel(carousel) {
      if (!carousel || carousel.dataset.inited) return;
      carousel.dataset.inited = '1';

      const track = carousel.querySelector('.hero-carousel-track');
      const prevBtn = carousel.querySelector('.hero-carousel-prev');
      const nextBtn = carousel.querySelector('.hero-carousel-next');
      const indicators = Array.from(carousel.querySelectorAll('.hero-carousel-indicators button'));
      const intervalMs = parseInt(carousel.getAttribute('data-interval') || '0', 10) || 5000;

      // Número real de slides (sin clones)
      let slides = Array.from(track.children);

      // Heavy setup (clones/listeners) deferred to idle to avoid blocking main load
      const setup = () => {
        const firstClone = slides[0].cloneNode(true);
        const lastClone  = slides[slides.length - 1].cloneNode(true);
        track.appendChild(firstClone);
        track.insertBefore(lastClone, track.firstChild);
        slides = Array.from(track.children); // ahora con clones

        let currentIndex = 1;
        let isTransitioning = false;
        let autoSlide;

        function getPerPage() {
          const w = window.innerWidth;
          if (w >= 1024) return 3;
          if (w >= 768) return 2;
          return 1;
        }

        function getSlideWidth() {
          return slides[0].getBoundingClientRect().width;
        }

        function goTo(index, smooth = true) {
          if (isTransitioning && smooth) return;
          track.style.transition = smooth ? 'transform 0.5s ease-in-out' : 'none';
          track.style.transform  = `translateX(-${getSlideWidth() * index}px)`;
          currentIndex = index;
          isTransitioning = smooth;
        }

        function updateIndicators() {
          let realIndex = currentIndex - 1;
          if (currentIndex === 0) realIndex = slides.length - 3;
          else if (currentIndex === slides.length - 1) realIndex = 0;
          indicators.forEach((btn, i) => btn.classList.toggle('bg-main', i === realIndex));
        }

        track.addEventListener('transitionend', () => {
          if (slides[currentIndex] === firstClone)  goTo(1, false);
          if (slides[currentIndex] === lastClone)   goTo(slides.length - 2, false);
          isTransitioning = false;
          updateIndicators();
        });

        prevBtn?.addEventListener('click', () => { goTo(currentIndex - getPerPage()); resetAuto(); });
        nextBtn?.addEventListener('click', () => { goTo(currentIndex + getPerPage()); resetAuto(); });

        indicators.forEach(btn => btn.addEventListener('click', () => { const idx = Number(btn.dataset.index) + 1; goTo(idx); resetAuto(); }));

        function startAuto() { autoSlide = setInterval(() => goTo(currentIndex + getPerPage()), intervalMs); }
        function stopAuto() { clearInterval(autoSlide); }
        function resetAuto() { stopAuto(); startAuto(); }

        carousel.addEventListener('mouseenter', stopAuto, { passive: true });
        carousel.addEventListener('mouseleave', startAuto, { passive: true });

        let startX = 0, deltaX = 0;
        track.addEventListener('touchstart', e => { startX = e.touches[0].clientX; stopAuto(); }, { passive: true });
        track.addEventListener('touchend', e => { deltaX = e.changedTouches[0].clientX - startX; if (Math.abs(deltaX) > 50) { const dir = deltaX < 0 ? 1 : -1; goTo(currentIndex + dir * getPerPage()); } resetAuto(); }, { passive: true });

        function init() { slides = Array.from(track.children); goTo(1, false); updateIndicators(); }
        window.addEventListener('resize', debounce(() => init(), 120));

        init();
        startAuto();
      };

      if ('requestIdleCallback' in window) requestIdleCallback(setup, { timeout: 1500 });
      else setTimeout(setup, 600);
    }

    // Observe carousels and init when visible
    const carousels = Array.from(document.querySelectorAll('.hero-carousel[data-interval]'));
    if (carousels.length === 0) return;

    if ('IntersectionObserver' in window) {
      const io = new IntersectionObserver((entries, obs) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            initCarousel(entry.target);
            obs.unobserve(entry.target);
          }
        });
      }, { root: null, rootMargin: '400px' });
      carousels.forEach(c => io.observe(c));
    } else {
      carousels.forEach(c => initCarousel(c));
    }
  })();
</script>