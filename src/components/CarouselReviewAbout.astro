---
interface Props {
  interval?: number;
}

const { interval = 8000 } = Astro.props as Props;
---

<div class="relative px-2 sm:px-5 lg:px-0 mx-auto max-w-[1080px] max-h-[255px] w-auto" data-interval={interval}>
  <!-- Prev arrow -->
  <button
    class="hidden md:flex absolute top-1/2 left-0 -translate-y-1/2 -translate-x-[40%] lg:-translate-x-full z-10 w-10 h-10 items-center justify-center text-[40px] text-secondary cursor-pointer review-prev"
    id="carousel-prev"
    aria-label="Previous slide"
  >
    ‹
  </button>

  <!-- Viewport -->
  <div class="overflow-hidden w-auto h-full">
    <div class="flex transition-transform duration-800 ease-in-out review-track h-full" id="carousel-track">
      {Array.from({ length: 4 }, (_, i) => (
        <div class="flex-shrink-0 w-full md:w-1/2 lg:w-1/3 h-full px-2 md:px-[10px]">
          <img
            src={`/main/item-0${i + 1}.png`}
            alt="Slide image"
            width="400"
            height="255"
            class="w-full h-full object-cover rounded-[15px]"
            loading="eager"
            decoding="async"
          />
        </div>
      ))}
    </div>
  </div>

  <!-- Next arrow -->
  <button
    class="hidden md:flex absolute top-1/2 right-0 -translate-y-1/2 translate-x-[40%] lg:translate-x-full z-10 w-10 h-10 items-center justify-center text-[40px] text-secondary cursor-pointer review-next"
    id="carousel-next"
    aria-label="Next slide"
  >
    ›
  </button>

  <!-- Mobile indicators -->
  <div class="flex md:hidden gap-4 justify-center mt-4 review-indicators" id="carousel-indicators">
    {Array.from({ length: 4 }, (_, i) => (
      <button
        class="w-2 h-2 rounded-full bg-[#D9D9D9]"
        data-index={i}
        id={`indicator-${i}`}
        aria-label={`Go to slide ${i + 1}`}
      />
    ))}
  </div>
</div>

<script is:inline>
  window.addEventListener('load', () => {
    const carousel = document.querySelector('[data-interval]');
    if (!carousel) return;
    
    const track = document.getElementById('carousel-track');
    const prevBtn = document.getElementById('carousel-prev');
    const nextBtn = document.getElementById('carousel-next');
    const indicators = Array.from(document.querySelectorAll('#carousel-indicators button'));
    const intervalMs = parseInt(carousel.getAttribute('data-interval') || '8000', 10);

    // Número real de slides (sin clones)
    let slides = Array.from(track.children);
    
    // Clonación para infinito - necesitamos más clones para desktop
    const originalSlides = [...slides];
    
    // Agregar clones al final
    originalSlides.forEach(slide => {
      const clone = slide.cloneNode(true);
      track.appendChild(clone);
    });
    
    // Agregar clones al inicio
    originalSlides.reverse().forEach(slide => {
      const clone = slide.cloneNode(true);
      track.insertBefore(clone, track.firstChild);
    });
    
    slides = Array.from(track.children); // ahora con clones
    let currentIndex = originalSlides.length; // empezar en las imágenes originales
    let isTransitioning = false;
    let autoSlide;

    // Siempre mover de uno en uno (no por páginas como CarouselHero)
    function getPerPage() {
      return 1; // Siempre avanzar de uno en uno
    }

    function getSlideWidth() {
      return slides[0].getBoundingClientRect().width;
    }

    function goTo(index, smooth = true) {
      if (isTransitioning && smooth) return;
      track.style.transition = smooth ? 'transform 0.5s ease-in-out' : 'none';
      track.style.transform = `translateX(-${getSlideWidth() * index}px)`;
      currentIndex = index;
      isTransitioning = smooth;
    }

    function updateIndicators() {
      // Calcular el índice real basado en las 4 imágenes originales
      const originalCount = 4;
      let realIndex = (currentIndex - originalCount) % originalCount;
      if (realIndex < 0) realIndex += originalCount;
      
      indicators.forEach((btn, i) => {
        if (i === realIndex) {
          btn.classList.remove('bg-[#D9D9D9]');
          btn.classList.add('bg-main');
        } else {
          btn.classList.remove('bg-main');
          btn.classList.add('bg-[#D9D9D9]');
        }
      });
    }

    // Ajusta al final de la transición para "loop infinito"
    track.addEventListener('transitionend', () => {
      const originalCount = 4;
      
      // Si estamos muy al final, saltar al inicio de las imágenes originales
      if (currentIndex >= slides.length - originalCount) {
        currentIndex = originalCount;
        goTo(currentIndex, false);
      }
      
      // Si estamos muy al inicio, saltar al final de las imágenes originales  
      if (currentIndex < originalCount) {
        currentIndex = slides.length - originalCount - 1;
        goTo(currentIndex, false);
      }
      
      isTransitioning = false;
      updateIndicators();
    });

    // Prev / Next: siempre de uno en uno
    prevBtn?.addEventListener('click', () => {
      goTo(currentIndex - getPerPage());
      resetAuto();
    });
    
    nextBtn?.addEventListener('click', () => {
      goTo(currentIndex + getPerPage());
      resetAuto();
    });

    // Indicadores móviles
    indicators.forEach(btn =>
      btn.addEventListener('click', () => {
        const idx = Number(btn.dataset.index);
        const originalCount = 4;
        currentIndex = originalCount + idx; // ir al slide específico en la sección original
        goTo(currentIndex);
        resetAuto();
      })
    );

    // Auto-slide
    function startAuto() { 
      autoSlide = setInterval(() => {
        goTo(currentIndex + getPerPage());
      }, intervalMs); 
    }
    
    function stopAuto() { 
      clearInterval(autoSlide); 
    }
    
    function resetAuto() { 
      stopAuto(); 
      startAuto(); 
    }

    carousel.addEventListener('mouseenter', stopAuto);
    carousel.addEventListener('mouseleave', startAuto);

    // Swipe touch
    let startX = 0, deltaX = 0;
    track.addEventListener('touchstart', e => {
      startX = e.touches[0].clientX;
      stopAuto();
    });
    
    track.addEventListener('touchend', e => {
      deltaX = e.changedTouches[0].clientX - startX;
      if (Math.abs(deltaX) > 50) {
        const dir = deltaX < 0 ? 1 : -1;
        goTo(currentIndex + dir * getPerPage());
      }
      resetAuto();
    });

    // Reposicionar en carga y en resize
    function init() {
      // Esperar a que las imágenes se carguen antes de calcular
      const images = track.querySelectorAll('img');
      let loadedImages = 0;
      const originalCount = 4;
      
      function checkAllImagesLoaded() {
        loadedImages++;
        if (loadedImages === images.length) {
          slides = Array.from(track.children);
          currentIndex = originalCount; // empezar en las imágenes originales
          goTo(currentIndex, false);
          updateIndicators();
        }
      }
      
      // Si las imágenes ya están cargadas
      if (images[0] && images[0].complete) {
        slides = Array.from(track.children);
        currentIndex = originalCount;
        goTo(currentIndex, false);
        updateIndicators();
      } else {
        // Esperar a que todas las imágenes se carguen
        images.forEach(img => {
          if (img.complete) {
            checkAllImagesLoaded();
          } else {
            img.addEventListener('load', checkAllImagesLoaded);
            img.addEventListener('error', checkAllImagesLoaded);
          }
        });
      }
    }
    
    window.addEventListener('resize', () => {
      // En resize, recalcular inmediatamente
      setTimeout(() => {
        goTo(currentIndex, false);
        updateIndicators();
      }, 100);
    });

    init();
    
    // Iniciar auto-slide después de un pequeño delay para asegurar que todo esté listo
    setTimeout(() => {
      startAuto();
    }, 100);
  });
</script>